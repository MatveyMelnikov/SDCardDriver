ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 1


   1              		.cpu cortex-m3
   2              		.arch armv7-m
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"stm32f1xx_hal_pwr.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.PWR_OverloadWfe,"ax",%progbits
  18              		.align	1
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  23              	PWR_OverloadWfe:
  24              	.LFB65:
  25              		.file 1 "Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c"
   1:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
   2:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   ******************************************************************************
   3:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @file    stm32f1xx_hal_pwr.c
   4:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @author  MCD Application Team
   5:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief   PWR HAL module driver.
   6:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *
   7:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *          This file provides firmware functions to manage the following
   8:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *          functionalities of the Power Controller (PWR) peripheral:
   9:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *           + Initialization/de-initialization functions
  10:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *           + Peripheral Control functions 
  11:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *
  12:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   ******************************************************************************
  13:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @attention
  14:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *
  15:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * Copyright (c) 2016 STMicroelectronics.
  16:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * All rights reserved.
  17:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *
  18:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * This software is licensed under terms that can be found in the LICENSE file
  19:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * in the root directory of this software component.
  20:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * If no LICENSE file comes with this software, it is provided AS-IS.
  21:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *
  22:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   ******************************************************************************
  23:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
  24:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  25:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Includes ------------------------------------------------------------------*/
  26:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #include "stm32f1xx_hal.h"
  27:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  28:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @addtogroup STM32F1xx_HAL_Driver
  29:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
  30:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
  31:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  32:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR PWR
  33:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief    PWR HAL module driver
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 2


  34:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
  35:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
  36:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  37:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #ifdef HAL_PWR_MODULE_ENABLED
  38:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  39:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Private typedef -----------------------------------------------------------*/
  40:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Private define ------------------------------------------------------------*/
  41:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  42:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_Private_Constants PWR Private Constants
  43:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
  44:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
  45:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   
  46:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_PVD_Mode_Mask PWR PVD Mode Mask
  47:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
  48:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */ 
  49:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PVD_MODE_IT               0x00010000U
  50:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PVD_MODE_EVT              0x00020000U
  51:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PVD_RISING_EDGE           0x00000001U
  52:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PVD_FALLING_EDGE          0x00000002U
  53:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
  54:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @}
  55:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
  56:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  57:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  58:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_register_alias_address PWR Register alias address
  59:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
  60:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */ 
  61:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* ------------- PWR registers bit address in the alias region ---------------*/
  62:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PWR_OFFSET               (PWR_BASE - PERIPH_BASE)
  63:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PWR_CR_OFFSET            0x00U
  64:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PWR_CSR_OFFSET           0x04U
  65:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PWR_CR_OFFSET_BB         (PWR_OFFSET + PWR_CR_OFFSET)
  66:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PWR_CSR_OFFSET_BB        (PWR_OFFSET + PWR_CSR_OFFSET)
  67:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
  68:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @}
  69:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
  70:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    
  71:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_CR_register_alias PWR CR Register alias address
  72:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
  73:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */  
  74:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* --- CR Register ---*/
  75:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Alias word address of LPSDSR bit */
  76:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define LPSDSR_BIT_NUMBER        PWR_CR_LPDS_Pos
  77:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define CR_LPSDSR_BB             ((uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (LPSDSR_BI
  78:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  79:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Alias word address of DBP bit */
  80:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define DBP_BIT_NUMBER            PWR_CR_DBP_Pos
  81:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define CR_DBP_BB                ((uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (DBP_BIT_N
  82:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  83:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Alias word address of PVDE bit */
  84:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PVDE_BIT_NUMBER           PWR_CR_PVDE_Pos
  85:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define CR_PVDE_BB               ((uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (PVDE_BIT_
  86:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  87:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
  88:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @}
  89:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
  90:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 3


  91:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_CSR_register_alias PWR CSR Register alias address
  92:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
  93:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
  94:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  95:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* --- CSR Register ---*/
  96:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Alias word address of EWUP1 bit */
  97:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define CSR_EWUP_BB(VAL)         ((uint32_t)(PERIPH_BB_BASE + (PWR_CSR_OFFSET_BB * 32U) + (POSITION
  98:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
  99:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @}
 100:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 101:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   
 102:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 103:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @}
 104:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 105:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 106:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Private variables ---------------------------------------------------------*/
 107:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Private function prototypes -----------------------------------------------*/
 108:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_Private_Functions PWR Private Functions
 109:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****  * brief   WFE cortex command overloaded for HAL_PWR_EnterSTOPMode usage only (see Workaround secti
 110:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****  * @{
 111:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****  */
 112:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** static void PWR_OverloadWfe(void);
 113:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 114:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Private functions ---------------------------------------------------------*/
 115:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** __NOINLINE
 116:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** static void PWR_OverloadWfe(void)
 117:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
  26              		.loc 1 117 1
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 1, uses_anonymous_args = 0
  30              		@ link register save eliminated.
  31 0000 80B4     		push	{r7}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 4
  34              		.cfi_offset 7, -4
  35 0002 00AF     		add	r7, sp, #0
  36              	.LCFI1:
  37              		.cfi_def_cfa_register 7
 118:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __asm volatile( "wfe" );
  38              		.loc 1 118 3
  39              		.syntax unified
  40              	@ 118 "Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
  41 0004 20BF     		wfe
  42              	@ 0 "" 2
 119:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __asm volatile( "nop" );
  43              		.loc 1 119 3
  44              	@ 119 "Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
  45 0006 00BF     		nop
  46              	@ 0 "" 2
 120:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
  47              		.loc 1 120 1
  48              		.thumb
  49              		.syntax unified
  50 0008 00BF     		nop
  51 000a BD46     		mov	sp, r7
  52              	.LCFI2:
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 4


  53              		.cfi_def_cfa_register 13
  54              		@ sp needed
  55 000c 80BC     		pop	{r7}
  56              	.LCFI3:
  57              		.cfi_restore 7
  58              		.cfi_def_cfa_offset 0
  59 000e 7047     		bx	lr
  60              		.cfi_endproc
  61              	.LFE65:
  63              		.section	.text.HAL_PWR_DeInit,"ax",%progbits
  64              		.align	1
  65              		.global	HAL_PWR_DeInit
  66              		.syntax unified
  67              		.thumb
  68              		.thumb_func
  70              	HAL_PWR_DeInit:
  71              	.LFB66:
 121:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 122:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 123:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @}
 124:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 125:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 126:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 127:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_Exported_Functions PWR Exported Functions
 128:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
 129:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 130:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 131:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_Exported_Functions_Group1 Initialization and de-initialization functions 
 132:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *  @brief   Initialization and de-initialization functions
 133:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *
 134:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** @verbatim
 135:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****  ===============================================================================
 136:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****               ##### Initialization and de-initialization functions #####
 137:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****  ===============================================================================
 138:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     [..]
 139:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       After reset, the backup domain (RTC registers, RTC backup data
 140:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       registers) is protected against possible unwanted
 141:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       write accesses.
 142:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       To enable access to the RTC Domain and RTC registers, proceed as follows:
 143:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****         (+) Enable the Power Controller (PWR) APB1 interface clock using the
 144:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****             __HAL_RCC_PWR_CLK_ENABLE() macro.
 145:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****         (+) Enable access to RTC domain using the HAL_PWR_EnableBkUpAccess() function.
 146:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 147:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** @endverbatim
 148:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
 149:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 150:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 151:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 152:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief  Deinitializes the PWR peripheral registers to their default reset values.  
 153:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 154:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 155:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_DeInit(void)
 156:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
  72              		.loc 1 156 1
  73              		.cfi_startproc
  74              		@ args = 0, pretend = 0, frame = 0
  75              		@ frame_needed = 1, uses_anonymous_args = 0
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 5


  76              		@ link register save eliminated.
  77 0000 80B4     		push	{r7}
  78              	.LCFI4:
  79              		.cfi_def_cfa_offset 4
  80              		.cfi_offset 7, -4
  81 0002 00AF     		add	r7, sp, #0
  82              	.LCFI5:
  83              		.cfi_def_cfa_register 7
 157:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __HAL_RCC_PWR_FORCE_RESET();
  84              		.loc 1 157 3
  85 0004 074B     		ldr	r3, .L3
  86 0006 1B69     		ldr	r3, [r3, #16]
  87 0008 064A     		ldr	r2, .L3
  88 000a 43F08053 		orr	r3, r3, #268435456
  89 000e 1361     		str	r3, [r2, #16]
 158:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __HAL_RCC_PWR_RELEASE_RESET();
  90              		.loc 1 158 3
  91 0010 044B     		ldr	r3, .L3
  92 0012 1B69     		ldr	r3, [r3, #16]
  93 0014 034A     		ldr	r2, .L3
  94 0016 23F08053 		bic	r3, r3, #268435456
  95 001a 1361     		str	r3, [r2, #16]
 159:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
  96              		.loc 1 159 1
  97 001c 00BF     		nop
  98 001e BD46     		mov	sp, r7
  99              	.LCFI6:
 100              		.cfi_def_cfa_register 13
 101              		@ sp needed
 102 0020 80BC     		pop	{r7}
 103              	.LCFI7:
 104              		.cfi_restore 7
 105              		.cfi_def_cfa_offset 0
 106 0022 7047     		bx	lr
 107              	.L4:
 108              		.align	2
 109              	.L3:
 110 0024 00100240 		.word	1073876992
 111              		.cfi_endproc
 112              	.LFE66:
 114              		.section	.text.HAL_PWR_EnableBkUpAccess,"ax",%progbits
 115              		.align	1
 116              		.global	HAL_PWR_EnableBkUpAccess
 117              		.syntax unified
 118              		.thumb
 119              		.thumb_func
 121              	HAL_PWR_EnableBkUpAccess:
 122              	.LFB67:
 160:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 161:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 162:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief  Enables access to the backup domain (RTC registers, RTC
 163:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         backup data registers ).
 164:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note   If the HSE divided by 128 is used as the RTC clock, the
 165:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         Backup Domain Access should be kept enabled.
 166:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 167:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 168:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnableBkUpAccess(void)
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 6


 169:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 123              		.loc 1 169 1
 124              		.cfi_startproc
 125              		@ args = 0, pretend = 0, frame = 0
 126              		@ frame_needed = 1, uses_anonymous_args = 0
 127              		@ link register save eliminated.
 128 0000 80B4     		push	{r7}
 129              	.LCFI8:
 130              		.cfi_def_cfa_offset 4
 131              		.cfi_offset 7, -4
 132 0002 00AF     		add	r7, sp, #0
 133              	.LCFI9:
 134              		.cfi_def_cfa_register 7
 170:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Enable access to RTC and backup registers */
 171:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *(__IO uint32_t *) CR_DBP_BB = (uint32_t)ENABLE;
 135              		.loc 1 171 3
 136 0004 034B     		ldr	r3, .L6
 137              		.loc 1 171 32
 138 0006 0122     		movs	r2, #1
 139 0008 1A60     		str	r2, [r3]
 172:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 140              		.loc 1 172 1
 141 000a 00BF     		nop
 142 000c BD46     		mov	sp, r7
 143              	.LCFI10:
 144              		.cfi_def_cfa_register 13
 145              		@ sp needed
 146 000e 80BC     		pop	{r7}
 147              	.LCFI11:
 148              		.cfi_restore 7
 149              		.cfi_def_cfa_offset 0
 150 0010 7047     		bx	lr
 151              	.L7:
 152 0012 00BF     		.align	2
 153              	.L6:
 154 0014 20000E42 		.word	1108213792
 155              		.cfi_endproc
 156              	.LFE67:
 158              		.section	.text.HAL_PWR_DisableBkUpAccess,"ax",%progbits
 159              		.align	1
 160              		.global	HAL_PWR_DisableBkUpAccess
 161              		.syntax unified
 162              		.thumb
 163              		.thumb_func
 165              	HAL_PWR_DisableBkUpAccess:
 166              	.LFB68:
 173:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 174:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 175:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief  Disables access to the backup domain (RTC registers, RTC
 176:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         backup data registers).
 177:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note   If the HSE divided by 128 is used as the RTC clock, the
 178:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         Backup Domain Access should be kept enabled.
 179:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 180:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 181:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_DisableBkUpAccess(void)
 182:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 167              		.loc 1 182 1
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 7


 168              		.cfi_startproc
 169              		@ args = 0, pretend = 0, frame = 0
 170              		@ frame_needed = 1, uses_anonymous_args = 0
 171              		@ link register save eliminated.
 172 0000 80B4     		push	{r7}
 173              	.LCFI12:
 174              		.cfi_def_cfa_offset 4
 175              		.cfi_offset 7, -4
 176 0002 00AF     		add	r7, sp, #0
 177              	.LCFI13:
 178              		.cfi_def_cfa_register 7
 183:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Disable access to RTC and backup registers */
 184:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *(__IO uint32_t *) CR_DBP_BB = (uint32_t)DISABLE;
 179              		.loc 1 184 3
 180 0004 034B     		ldr	r3, .L9
 181              		.loc 1 184 32
 182 0006 0022     		movs	r2, #0
 183 0008 1A60     		str	r2, [r3]
 185:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 184              		.loc 1 185 1
 185 000a 00BF     		nop
 186 000c BD46     		mov	sp, r7
 187              	.LCFI14:
 188              		.cfi_def_cfa_register 13
 189              		@ sp needed
 190 000e 80BC     		pop	{r7}
 191              	.LCFI15:
 192              		.cfi_restore 7
 193              		.cfi_def_cfa_offset 0
 194 0010 7047     		bx	lr
 195              	.L10:
 196 0012 00BF     		.align	2
 197              	.L9:
 198 0014 20000E42 		.word	1108213792
 199              		.cfi_endproc
 200              	.LFE68:
 202              		.section	.text.HAL_PWR_ConfigPVD,"ax",%progbits
 203              		.align	1
 204              		.global	HAL_PWR_ConfigPVD
 205              		.syntax unified
 206              		.thumb
 207              		.thumb_func
 209              	HAL_PWR_ConfigPVD:
 210              	.LFB69:
 186:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 187:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 188:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @}
 189:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 190:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 191:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_Exported_Functions_Group2 Peripheral Control functions 
 192:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief    Low Power modes configuration functions
 193:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *
 194:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** @verbatim
 195:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****  ===============================================================================
 196:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****                  ##### Peripheral Control functions #####
 197:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****  ===============================================================================
 198:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****      
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 8


 199:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     *** PVD configuration ***
 200:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     =========================
 201:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     [..]
 202:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) The PVD is used to monitor the VDD power supply by comparing it to a
 203:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           threshold selected by the PVD Level (PLS[2:0] bits in the PWR_CR).
 204:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 205:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) A PVDO flag is available to indicate if VDD/VDDA is higher or lower
 206:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           than the PVD threshold. This event is internally connected to the EXTI
 207:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           line16 and can generate an interrupt if enabled. This is done through
 208:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           __HAL_PVD_EXTI_ENABLE_IT() macro.
 209:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) The PVD is stopped in Standby mode.
 210:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 211:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     *** WakeUp pin configuration ***
 212:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     ================================
 213:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     [..]
 214:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) WakeUp pin is used to wake up the system from Standby mode. This pin is
 215:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           forced in input pull-down configuration and is active on rising edges.
 216:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) There is one WakeUp pin:
 217:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           WakeUp Pin 1 on PA.00.
 218:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 219:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     [..]
 220:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 221:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     *** Low Power modes configuration ***
 222:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     =====================================
 223:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****      [..]
 224:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       The device features 3 low-power modes:
 225:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Sleep mode: CPU clock off, all peripherals including Cortex-M3 core peripherals like 
 226:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****                       NVIC, SysTick, etc. are kept running
 227:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Stop mode: All clocks are stopped
 228:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Standby mode: 1.8V domain powered off
 229:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   
 230:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   
 231:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    *** Sleep mode ***
 232:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    ==================
 233:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     [..]
 234:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Entry:
 235:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           The Sleep mode is entered by using the HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_S
 236:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****               functions with
 237:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
 238:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
 239:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****      
 240:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Exit:
 241:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****         (++) WFI entry mode, Any peripheral interrupt acknowledged by the nested vectored interrupt
 242:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****              controller (NVIC) can wake up the device from Sleep mode.
 243:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****         (++) WFE entry mode, Any wakeup event can wake up the device from Sleep mode.
 244:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****            (+++) Any peripheral interrupt w/o NVIC configuration & SEVONPEND bit set in the Cortex 
 245:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****            (+++) Any EXTI Line (Internal or External) configured in Event mode
 246:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 247:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    *** Stop mode ***
 248:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    =================
 249:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     [..]
 250:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       The Stop mode is based on the Cortex-M3 deepsleep mode combined with peripheral
 251:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       clock gating. The voltage regulator can be configured either in normal or low-power mode.
 252:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       In Stop mode, all clocks in the 1.8 V domain are stopped, the PLL, the HSI and the HSE RC 
 253:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       oscillators are disabled. SRAM and register contents are preserved.
 254:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       In Stop mode, all I/O pins keep the same state as in Run mode.
 255:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 9


 256:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Entry:
 257:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****            The Stop mode is entered using the HAL_PWR_EnterSTOPMode(PWR_REGULATOR_VALUE, PWR_SLEEPE
 258:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****              function with:
 259:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (++) PWR_REGULATOR_VALUE= PWR_MAINREGULATOR_ON: Main regulator ON.
 260:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (++) PWR_REGULATOR_VALUE= PWR_LOWPOWERREGULATOR_ON: Low Power regulator ON.
 261:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFx= PWR_SLEEPENTRY_WFI: enter STOP mode with WFI instruction
 262:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFx= PWR_SLEEPENTRY_WFE: enter STOP mode with WFE instruction
 263:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Exit:
 264:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (++) WFI entry mode, Any EXTI Line (Internal or External) configured in Interrupt mode wi
 265:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (++) WFE entry mode, Any EXTI Line (Internal or External) configured in Event mode.
 266:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 267:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    *** Standby mode ***
 268:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    ====================
 269:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****      [..]
 270:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       The Standby mode allows to achieve the lowest power consumption. It is based on the
 271:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       Cortex-M3 deepsleep mode, with the voltage regulator disabled. The 1.8 V domain is 
 272:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       consequently powered off. The PLL, the HSI oscillator and the HSE oscillator are also 
 273:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       switched off. SRAM and register contents are lost except for registers in the Backup domain 
 274:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       and Standby circuitry
 275:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       
 276:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Entry:
 277:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****         (++) The Standby mode is entered using the HAL_PWR_EnterSTANDBYMode() function.
 278:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Exit:
 279:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****         (++) WKUP pin rising edge, RTC alarm event rising edge, external Reset in 
 280:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****              NRSTpin, IWDG Reset
 281:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 282:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    *** Auto-wakeup (AWU) from low-power mode ***
 283:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****        =============================================
 284:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****        [..]
 285:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****         
 286:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****        (+) The MCU can be woken up from low-power mode by an RTC Alarm event, 
 287:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****            without depending on an external interrupt (Auto-wakeup mode).
 288:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    
 289:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****        (+) RTC auto-wakeup (AWU) from the Stop and Standby modes
 290:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 291:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****            (++) To wake up from the Stop mode with an RTC alarm event, it is necessary to 
 292:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****                 configure the RTC to generate the RTC alarm using the HAL_RTC_SetAlarm_IT() functio
 293:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 294:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    *** PWR Workarounds linked to Silicon Limitation ***
 295:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****        ====================================================
 296:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****        [..]
 297:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****        Below the list of all silicon limitations known on STM32F1xx prouct.
 298:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 299:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****        (#)Workarounds Implemented inside PWR HAL Driver
 300:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (##)Debugging Stop mode with WFE entry - overloaded the WFE by an internal function    
 301:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****         
 302:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** @endverbatim
 303:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
 304:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 305:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 306:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 307:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief  Configures the voltage threshold detected by the Power Voltage Detector(PVD).
 308:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @param  sConfigPVD: pointer to an PWR_PVDTypeDef structure that contains the configuration
 309:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         information for the PVD.
 310:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note   Refer to the electrical characteristics of your device datasheet for
 311:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         more details about the voltage threshold corresponding to each
 312:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         detection level.
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 10


 313:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 314:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 315:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD)
 316:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 211              		.loc 1 316 1
 212              		.cfi_startproc
 213              		@ args = 0, pretend = 0, frame = 8
 214              		@ frame_needed = 1, uses_anonymous_args = 0
 215              		@ link register save eliminated.
 216 0000 80B4     		push	{r7}
 217              	.LCFI16:
 218              		.cfi_def_cfa_offset 4
 219              		.cfi_offset 7, -4
 220 0002 83B0     		sub	sp, sp, #12
 221              	.LCFI17:
 222              		.cfi_def_cfa_offset 16
 223 0004 00AF     		add	r7, sp, #0
 224              	.LCFI18:
 225              		.cfi_def_cfa_register 7
 226 0006 7860     		str	r0, [r7, #4]
 317:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Check the parameters */
 318:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));
 319:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));
 320:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 321:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Set PLS[7:5] bits according to PVDLevel value */
 322:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   MODIFY_REG(PWR->CR, PWR_CR_PLS, sConfigPVD->PVDLevel);
 227              		.loc 1 322 3
 228 0008 2A4B     		ldr	r3, .L17
 229 000a 1B68     		ldr	r3, [r3]
 230 000c 23F0E002 		bic	r2, r3, #224
 231 0010 7B68     		ldr	r3, [r7, #4]
 232 0012 1B68     		ldr	r3, [r3]
 233 0014 2749     		ldr	r1, .L17
 234 0016 1343     		orrs	r3, r3, r2
 235 0018 0B60     		str	r3, [r1]
 323:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   
 324:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Clear any previous config. Keep it clear if no event or IT mode is selected */
 325:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_EVENT();
 236              		.loc 1 325 3
 237 001a 274B     		ldr	r3, .L17+4
 238 001c 5B68     		ldr	r3, [r3, #4]
 239 001e 264A     		ldr	r2, .L17+4
 240 0020 23F48033 		bic	r3, r3, #65536
 241 0024 5360     		str	r3, [r2, #4]
 326:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_IT();
 242              		.loc 1 326 3
 243 0026 244B     		ldr	r3, .L17+4
 244 0028 1B68     		ldr	r3, [r3]
 245 002a 234A     		ldr	r2, .L17+4
 246 002c 23F48033 		bic	r3, r3, #65536
 247 0030 1360     		str	r3, [r2]
 327:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); 
 248              		.loc 1 327 3
 249 0032 214B     		ldr	r3, .L17+4
 250 0034 DB68     		ldr	r3, [r3, #12]
 251 0036 204A     		ldr	r2, .L17+4
 252 0038 23F48033 		bic	r3, r3, #65536
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 11


 253 003c D360     		str	r3, [r2, #12]
 328:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();
 254              		.loc 1 328 3
 255 003e 1E4B     		ldr	r3, .L17+4
 256 0040 9B68     		ldr	r3, [r3, #8]
 257 0042 1D4A     		ldr	r2, .L17+4
 258 0044 23F48033 		bic	r3, r3, #65536
 259 0048 9360     		str	r3, [r2, #8]
 329:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 330:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Configure interrupt mode */
 331:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
 260              		.loc 1 331 17
 261 004a 7B68     		ldr	r3, [r7, #4]
 262 004c 5B68     		ldr	r3, [r3, #4]
 263              		.loc 1 331 24
 264 004e 03F48033 		and	r3, r3, #65536
 265              		.loc 1 331 5
 266 0052 002B     		cmp	r3, #0
 267 0054 05D0     		beq	.L12
 332:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
 333:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_IT();
 268              		.loc 1 333 5
 269 0056 184B     		ldr	r3, .L17+4
 270 0058 1B68     		ldr	r3, [r3]
 271 005a 174A     		ldr	r2, .L17+4
 272 005c 43F48033 		orr	r3, r3, #65536
 273 0060 1360     		str	r3, [r2]
 274              	.L12:
 334:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 335:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   
 336:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Configure event mode */
 337:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
 275              		.loc 1 337 17
 276 0062 7B68     		ldr	r3, [r7, #4]
 277 0064 5B68     		ldr	r3, [r3, #4]
 278              		.loc 1 337 24
 279 0066 03F40033 		and	r3, r3, #131072
 280              		.loc 1 337 5
 281 006a 002B     		cmp	r3, #0
 282 006c 05D0     		beq	.L13
 338:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
 339:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_EVENT();
 283              		.loc 1 339 5
 284 006e 124B     		ldr	r3, .L17+4
 285 0070 5B68     		ldr	r3, [r3, #4]
 286 0072 114A     		ldr	r2, .L17+4
 287 0074 43F48033 		orr	r3, r3, #65536
 288 0078 5360     		str	r3, [r2, #4]
 289              	.L13:
 340:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 341:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   
 342:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Configure the edge */
 343:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
 290              		.loc 1 343 17
 291 007a 7B68     		ldr	r3, [r7, #4]
 292 007c 5B68     		ldr	r3, [r3, #4]
 293              		.loc 1 343 24
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 12


 294 007e 03F00103 		and	r3, r3, #1
 295              		.loc 1 343 5
 296 0082 002B     		cmp	r3, #0
 297 0084 05D0     		beq	.L14
 344:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
 345:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();
 298              		.loc 1 345 5
 299 0086 0C4B     		ldr	r3, .L17+4
 300 0088 9B68     		ldr	r3, [r3, #8]
 301 008a 0B4A     		ldr	r2, .L17+4
 302 008c 43F48033 		orr	r3, r3, #65536
 303 0090 9360     		str	r3, [r2, #8]
 304              	.L14:
 346:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 347:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   
 348:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
 305              		.loc 1 348 17
 306 0092 7B68     		ldr	r3, [r7, #4]
 307 0094 5B68     		ldr	r3, [r3, #4]
 308              		.loc 1 348 24
 309 0096 03F00203 		and	r3, r3, #2
 310              		.loc 1 348 5
 311 009a 002B     		cmp	r3, #0
 312 009c 05D0     		beq	.L16
 349:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
 350:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();
 313              		.loc 1 350 5
 314 009e 064B     		ldr	r3, .L17+4
 315 00a0 DB68     		ldr	r3, [r3, #12]
 316 00a2 054A     		ldr	r2, .L17+4
 317 00a4 43F48033 		orr	r3, r3, #65536
 318 00a8 D360     		str	r3, [r2, #12]
 319              	.L16:
 351:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 352:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 320              		.loc 1 352 1
 321 00aa 00BF     		nop
 322 00ac 0C37     		adds	r7, r7, #12
 323              	.LCFI19:
 324              		.cfi_def_cfa_offset 4
 325 00ae BD46     		mov	sp, r7
 326              	.LCFI20:
 327              		.cfi_def_cfa_register 13
 328              		@ sp needed
 329 00b0 80BC     		pop	{r7}
 330              	.LCFI21:
 331              		.cfi_restore 7
 332              		.cfi_def_cfa_offset 0
 333 00b2 7047     		bx	lr
 334              	.L18:
 335              		.align	2
 336              	.L17:
 337 00b4 00700040 		.word	1073770496
 338 00b8 00040140 		.word	1073808384
 339              		.cfi_endproc
 340              	.LFE69:
 342              		.section	.text.HAL_PWR_EnablePVD,"ax",%progbits
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 13


 343              		.align	1
 344              		.global	HAL_PWR_EnablePVD
 345              		.syntax unified
 346              		.thumb
 347              		.thumb_func
 349              	HAL_PWR_EnablePVD:
 350              	.LFB70:
 353:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 354:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 355:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief  Enables the Power Voltage Detector(PVD).
 356:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 357:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 358:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnablePVD(void)
 359:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 351              		.loc 1 359 1
 352              		.cfi_startproc
 353              		@ args = 0, pretend = 0, frame = 0
 354              		@ frame_needed = 1, uses_anonymous_args = 0
 355              		@ link register save eliminated.
 356 0000 80B4     		push	{r7}
 357              	.LCFI22:
 358              		.cfi_def_cfa_offset 4
 359              		.cfi_offset 7, -4
 360 0002 00AF     		add	r7, sp, #0
 361              	.LCFI23:
 362              		.cfi_def_cfa_register 7
 360:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Enable the power voltage detector */
 361:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)ENABLE;
 363              		.loc 1 361 3
 364 0004 034B     		ldr	r3, .L20
 365              		.loc 1 361 33
 366 0006 0122     		movs	r2, #1
 367 0008 1A60     		str	r2, [r3]
 362:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 368              		.loc 1 362 1
 369 000a 00BF     		nop
 370 000c BD46     		mov	sp, r7
 371              	.LCFI24:
 372              		.cfi_def_cfa_register 13
 373              		@ sp needed
 374 000e 80BC     		pop	{r7}
 375              	.LCFI25:
 376              		.cfi_restore 7
 377              		.cfi_def_cfa_offset 0
 378 0010 7047     		bx	lr
 379              	.L21:
 380 0012 00BF     		.align	2
 381              	.L20:
 382 0014 10000E42 		.word	1108213776
 383              		.cfi_endproc
 384              	.LFE70:
 386              		.section	.text.HAL_PWR_DisablePVD,"ax",%progbits
 387              		.align	1
 388              		.global	HAL_PWR_DisablePVD
 389              		.syntax unified
 390              		.thumb
 391              		.thumb_func
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 14


 393              	HAL_PWR_DisablePVD:
 394              	.LFB71:
 363:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 364:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 365:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief  Disables the Power Voltage Detector(PVD).
 366:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 367:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 368:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_DisablePVD(void)
 369:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 395              		.loc 1 369 1
 396              		.cfi_startproc
 397              		@ args = 0, pretend = 0, frame = 0
 398              		@ frame_needed = 1, uses_anonymous_args = 0
 399              		@ link register save eliminated.
 400 0000 80B4     		push	{r7}
 401              	.LCFI26:
 402              		.cfi_def_cfa_offset 4
 403              		.cfi_offset 7, -4
 404 0002 00AF     		add	r7, sp, #0
 405              	.LCFI27:
 406              		.cfi_def_cfa_register 7
 370:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Disable the power voltage detector */
 371:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)DISABLE;
 407              		.loc 1 371 3
 408 0004 034B     		ldr	r3, .L23
 409              		.loc 1 371 33
 410 0006 0022     		movs	r2, #0
 411 0008 1A60     		str	r2, [r3]
 372:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 412              		.loc 1 372 1
 413 000a 00BF     		nop
 414 000c BD46     		mov	sp, r7
 415              	.LCFI28:
 416              		.cfi_def_cfa_register 13
 417              		@ sp needed
 418 000e 80BC     		pop	{r7}
 419              	.LCFI29:
 420              		.cfi_restore 7
 421              		.cfi_def_cfa_offset 0
 422 0010 7047     		bx	lr
 423              	.L24:
 424 0012 00BF     		.align	2
 425              	.L23:
 426 0014 10000E42 		.word	1108213776
 427              		.cfi_endproc
 428              	.LFE71:
 430              		.section	.text.HAL_PWR_EnableWakeUpPin,"ax",%progbits
 431              		.align	1
 432              		.global	HAL_PWR_EnableWakeUpPin
 433              		.syntax unified
 434              		.thumb
 435              		.thumb_func
 437              	HAL_PWR_EnableWakeUpPin:
 438              	.LFB72:
 373:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 374:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 375:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Enables the WakeUp PINx functionality.
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 15


 376:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @param WakeUpPinx: Specifies the Power Wake-Up pin to enable.
 377:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *        This parameter can be one of the following values:
 378:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *           @arg PWR_WAKEUP_PIN1
 379:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 380:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 381:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnableWakeUpPin(uint32_t WakeUpPinx)
 382:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 439              		.loc 1 382 1
 440              		.cfi_startproc
 441              		@ args = 0, pretend = 0, frame = 16
 442              		@ frame_needed = 1, uses_anonymous_args = 0
 443              		@ link register save eliminated.
 444 0000 80B4     		push	{r7}
 445              	.LCFI30:
 446              		.cfi_def_cfa_offset 4
 447              		.cfi_offset 7, -4
 448 0002 85B0     		sub	sp, sp, #20
 449              	.LCFI31:
 450              		.cfi_def_cfa_offset 24
 451 0004 00AF     		add	r7, sp, #0
 452              	.LCFI32:
 453              		.cfi_def_cfa_register 7
 454 0006 7860     		str	r0, [r7, #4]
 455 0008 7B68     		ldr	r3, [r7, #4]
 456 000a FB60     		str	r3, [r7, #12]
 457              	.LBB6:
 458              	.LBB7:
 459              		.file 2 "Drivers/CMSIS/Include/cmsis_gcc.h"
   1:Drivers/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @version  V5.0.4
   5:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @date     09. April 2018
   6:Drivers/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:Drivers/CMSIS/Include/cmsis_gcc.h **** /*
   8:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
   9:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  10:Drivers/CMSIS/Include/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  12:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:Drivers/CMSIS/Include/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:Drivers/CMSIS/Include/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  16:Drivers/CMSIS/Include/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  18:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:Drivers/CMSIS/Include/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:Drivers/CMSIS/Include/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:Drivers/CMSIS/Include/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:Drivers/CMSIS/Include/cmsis_gcc.h ****  * limitations under the License.
  23:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  24:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  25:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  28:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 16


  30:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  34:Drivers/CMSIS/Include/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __has_builtin
  36:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  38:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  39:Drivers/CMSIS/Include/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ASM
  41:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  43:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __INLINE
  44:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __INLINE                               inline
  45:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  46:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  49:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_FORCEINLINE                 
  50:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
  51:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif                                           
  52:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __NO_RETURN
  53:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((__noreturn__))
  54:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  55:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __USED
  56:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  57:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  58:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __WEAK
  59:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  60:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  61:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED
  62:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  63:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  64:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  65:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  66:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  67:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  68:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  69:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  70:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  71:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  72:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  73:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  74:Drivers/CMSIS/Include/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  75:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  76:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  77:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  78:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  79:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  80:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  81:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  82:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  83:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  84:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  85:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  86:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 17


  87:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  88:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  89:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  90:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  91:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  92:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  93:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  94:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  95:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  96:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  97:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  98:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  99:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 100:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
 101:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 102:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 103:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
 104:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 105:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 106:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 107:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 108:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 109:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 110:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ALIGNED
 111:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 112:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 113:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __RESTRICT
 114:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 115:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 116:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 117:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 118:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 119:Drivers/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 120:Drivers/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 121:Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
 122:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 123:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 124:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 125:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 126:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 127:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 128:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 129:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_irq(void)
 130:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 131:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 132:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 133:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 134:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 135:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 136:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 137:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 138:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 139:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 140:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_irq(void)
 141:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 142:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 143:Drivers/CMSIS/Include/cmsis_gcc.h **** }
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 18


 144:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 145:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 146:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 147:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register
 148:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the Control Register.
 149:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Control Register value
 150:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 151:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
 152:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 153:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 154:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 155:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 156:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 157:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 158:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 159:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 160:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 161:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 162:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 163:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 164:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               non-secure Control Register value
 165:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 166:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_CONTROL_NS(void)
 167:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 168:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 169:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 170:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 171:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 172:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 173:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 174:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 175:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 176:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 177:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register
 178:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 179:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 180:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 181:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
 182:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 183:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 184:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 185:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 186:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 187:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 188:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 189:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 190:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 191:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 192:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 193:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)
 194:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 195:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 196:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 197:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 198:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 199:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 200:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 19


 201:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get IPSR Register
 202:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 203:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               IPSR Register value
 204:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 205:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_IPSR(void)
 206:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 207:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 208:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 209:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 210:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 211:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 212:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 213:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 214:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 215:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get APSR Register
 216:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 217:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               APSR Register value
 218:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 219:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_APSR(void)
 220:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 221:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 222:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 223:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 224:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 225:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 226:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 227:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 228:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 229:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get xPSR Register
 230:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 231:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               xPSR Register value
 232:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 233:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_xPSR(void)
 234:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 235:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 236:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 237:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 238:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 239:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 240:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 241:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 242:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 243:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 244:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 245:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 246:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 247:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSP(void)
 248:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 249:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 250:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 251:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 252:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 253:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 254:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 255:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 256:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 257:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 20


 258:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 259:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 260:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 261:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 262:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSP_NS(void)
 263:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 264:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 265:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 266:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 267:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 268:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 269:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 270:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 271:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 272:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 273:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 274:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 275:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 276:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 277:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
 278:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 279:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 280:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 281:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 282:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 283:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 284:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 285:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 286:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 287:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 288:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 289:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 290:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 291:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 292:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 293:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 294:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 295:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 296:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 297:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 298:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 299:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 300:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 301:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSP(void)
 302:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 303:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 304:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 305:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 306:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 307:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 308:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 309:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 310:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 311:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 312:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 313:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 314:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 21


 315:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 316:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSP_NS(void)
 317:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 318:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 319:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 320:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 321:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 322:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 323:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 324:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 325:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 326:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 327:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 328:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 329:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 330:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 331:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
 332:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 333:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 334:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 335:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 336:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 337:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 338:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 339:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 340:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 341:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 342:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 343:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 344:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 345:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 346:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 347:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 348:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 349:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 350:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 351:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 352:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Stack Pointer (non-secure)
 353:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
 354:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               SP Register value
 355:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 356:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_SP_NS(void)
 357:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 358:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 359:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 360:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, sp_ns" : "=r" (result) );
 361:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 362:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 363:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 364:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 365:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 366:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Stack Pointer (non-secure)
 367:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
 368:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfStack  Stack Pointer value to set
 369:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 370:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_SP_NS(uint32_t topOfStack)
 371:Drivers/CMSIS/Include/cmsis_gcc.h **** {
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 22


 372:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
 373:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 374:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 375:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 376:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 377:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 378:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask
 379:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 380:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 381:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 382:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
 383:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 384:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 385:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 386:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 387:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 388:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 389:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 390:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 391:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 392:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 393:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 394:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 395:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 396:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 397:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PRIMASK_NS(void)
 398:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 399:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 400:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 401:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) :: "memory");
 402:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 403:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 404:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 405:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 406:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 407:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 408:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask
 409:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 410:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 411:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 412:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
 413:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 414:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 415:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 416:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 417:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 418:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 419:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 420:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask (non-secure)
 421:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
 422:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 423:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 424:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)
 425:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 426:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
 427:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 428:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 23


 429:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 430:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 431:Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 432:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 433:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 434:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 435:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable FIQ
 436:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 437:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 438:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 439:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_fault_irq(void)
 440:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 441:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 442:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 443:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 444:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 445:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 446:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable FIQ
 447:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 448:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 449:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 450:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_fault_irq(void)
 451:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 452:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 453:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 454:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 455:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 456:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 457:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority
 458:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 459:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 460:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 461:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_BASEPRI(void)
 462:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 463:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 464:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 465:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 466:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 467:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 468:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 469:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 470:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 471:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 472:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority (non-secure)
 473:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Base Priority register when in secure state.
 474:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 475:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 476:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_BASEPRI_NS(void)
 477:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 478:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 479:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 480:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri_ns" : "=r" (result) );
 481:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 482:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 483:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 484:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 485:Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 24


 486:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 487:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority
 488:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 489:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 490:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 491:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
 492:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 493:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 494:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 495:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 496:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 497:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 498:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 499:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority (non-secure)
 500:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Base Priority register when in secure state.
 501:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 502:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 503:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)
 504:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 505:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_ns, %0" : : "r" (basePri) : "memory");
 506:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 507:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 508:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 509:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 510:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 511:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 512:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 513:Drivers/CMSIS/Include/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 514:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 515:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 516:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI_MAX(uint32_t basePri)
 517:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 518:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 519:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 520:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 521:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 522:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 523:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask
 524:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 525:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 526:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 527:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FAULTMASK(void)
 528:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 529:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 530:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 531:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 532:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 533:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 534:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 535:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 536:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 537:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 538:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask (non-secure)
 539:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Fault Mask register when in secure state.
 540:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 541:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 542:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_FAULTMASK_NS(void)
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 25


 543:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 544:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 545:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 546:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask_ns" : "=r" (result) );
 547:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 548:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 549:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 550:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 551:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 552:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 553:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask
 554:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 555:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 556:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 557:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FAULTMASK(uint32_t faultMask)
 558:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 559:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 560:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 561:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 562:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 563:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 564:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 565:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask (non-secure)
 566:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Fault Mask register when in secure state.
 567:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 568:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 569:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)
 570:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 571:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask_ns, %0" : : "r" (faultMask) : "memory");
 572:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 573:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 574:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 575:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 576:Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 577:Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 578:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 579:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 580:Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 581:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 582:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 583:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 584:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit
 585:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 586:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 587:Drivers/CMSIS/Include/cmsis_gcc.h ****   mode.
 588:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 589:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
 590:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 591:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 592:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSPLIM(void)
 593:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 594:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 595:Drivers/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 596:Drivers/CMSIS/Include/cmsis_gcc.h ****     // without main extensions, the non-secure PSPLIM is RAZ/WI
 597:Drivers/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 598:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 599:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 26


 600:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim"  : "=r" (result) );
 601:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 602:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 603:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 604:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 605:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3))
 606:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 607:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit (non-secure)
 608:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 609:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 610:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 611:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in
 612:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 613:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 614:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSPLIM_NS(void)
 615:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 616:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 617:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 618:Drivers/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 619:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 620:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 621:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim_ns"  : "=r" (result) );
 622:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 623:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 624:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 625:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 626:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 627:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 628:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 629:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer Limit
 630:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 631:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 632:Drivers/CMSIS/Include/cmsis_gcc.h ****   mode.
 633:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 634:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
 635:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 636:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 637:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)
 638:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 639:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 640:Drivers/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 641:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 642:Drivers/CMSIS/Include/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 643:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 644:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 645:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 646:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 647:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 648:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 649:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 650:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 651:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 652:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 653:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 654:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 655:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in s
 656:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 27


 657:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 658:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)
 659:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 660:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 661:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 662:Drivers/CMSIS/Include/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 663:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 664:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim_ns, %0\n" : : "r" (ProcStackPtrLimit));
 665:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 666:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 667:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 668:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 669:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 670:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 671:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit
 672:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 673:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 674:Drivers/CMSIS/Include/cmsis_gcc.h ****   mode.
 675:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 676:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
 677:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 678:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 679:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSPLIM(void)
 680:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 681:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 682:Drivers/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 683:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 684:Drivers/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 685:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 686:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 687:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim" : "=r" (result) );
 688:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 689:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 690:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 691:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 692:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 693:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 694:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 695:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit (non-secure)
 696:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 697:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 698:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 699:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in sec
 700:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 701:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 702:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSPLIM_NS(void)
 703:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 704:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 705:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 706:Drivers/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 707:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 708:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 709:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim_ns" : "=r" (result) );
 710:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 711:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 712:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 713:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 28


 714:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 715:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 716:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 717:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit
 718:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 719:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 720:Drivers/CMSIS/Include/cmsis_gcc.h ****   mode.
 721:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 722:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
 723:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
 724:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 725:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)
 726:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 727:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 728:Drivers/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 729:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 730:Drivers/CMSIS/Include/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 731:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 732:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 733:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 734:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 735:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 736:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 737:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 738:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 739:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit (non-secure)
 740:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 741:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 742:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 743:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secu
 744:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
 745:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 746:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)
 747:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 748:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 749:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 750:Drivers/CMSIS/Include/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 751:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 752:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim_ns, %0" : : "r" (MainStackPtrLimit));
 753:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 754:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 755:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 756:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 757:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 758:Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 759:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 760:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 761:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 762:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get FPSCR
 763:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 764:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 765:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 766:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FPSCR(void)
 767:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 768:Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 769:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 770:Drivers/CMSIS/Include/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_get_fpscr) 
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 29


 771:Drivers/CMSIS/Include/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 772:Drivers/CMSIS/Include/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 773:Drivers/CMSIS/Include/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 774:Drivers/CMSIS/Include/cmsis_gcc.h ****   return __builtin_arm_get_fpscr();
 775:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 776:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 777:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 778:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 779:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 780:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 781:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 782:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(0U);
 783:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 784:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 785:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 786:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 787:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 788:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set FPSCR
 789:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 790:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 791:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 792:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FPSCR(uint32_t fpscr)
 793:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 794:Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 795:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 796:Drivers/CMSIS/Include/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_set_fpscr)
 797:Drivers/CMSIS/Include/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 798:Drivers/CMSIS/Include/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 799:Drivers/CMSIS/Include/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 800:Drivers/CMSIS/Include/cmsis_gcc.h ****   __builtin_arm_set_fpscr(fpscr);
 801:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 802:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
 803:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 804:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 805:Drivers/CMSIS/Include/cmsis_gcc.h ****   (void)fpscr;
 806:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 807:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 808:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 809:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 810:Drivers/CMSIS/Include/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 811:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 812:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 813:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 814:Drivers/CMSIS/Include/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 815:Drivers/CMSIS/Include/cmsis_gcc.h ****   Access to dedicated instructions
 816:Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
 817:Drivers/CMSIS/Include/cmsis_gcc.h **** */
 818:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 819:Drivers/CMSIS/Include/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 820:Drivers/CMSIS/Include/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 821:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 822:Drivers/CMSIS/Include/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 823:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 824:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+l" (r)
 825:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 826:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 827:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 30


 828:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+r" (r)
 829:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 830:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 831:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 832:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 833:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   No Operation
 834:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 835:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 836:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __NOP()                             __ASM volatile ("nop")
 837:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 838:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 839:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Interrupt
 840:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 841:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 842:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __WFI()                             __ASM volatile ("wfi")
 843:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 844:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 845:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 846:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Event
 847:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 848:Drivers/CMSIS/Include/cmsis_gcc.h ****            a low-power state until one of a number of events occurs.
 849:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 850:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __WFE()                             __ASM volatile ("wfe")
 851:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 852:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 853:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 854:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Send Event
 855:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 856:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 857:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __SEV()                             __ASM volatile ("sev")
 858:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 859:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 860:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 861:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 862:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 863:Drivers/CMSIS/Include/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 864:Drivers/CMSIS/Include/cmsis_gcc.h ****            after the instruction has been completed.
 865:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 866:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __ISB(void)
 867:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 868:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 869:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 870:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 871:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 872:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 873:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 874:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 875:Drivers/CMSIS/Include/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 876:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 877:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DSB(void)
 878:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 879:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 880:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 881:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 882:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 883:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 884:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Memory Barrier
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 31


 885:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Ensures the apparent order of the explicit memory operations before
 886:Drivers/CMSIS/Include/cmsis_gcc.h ****            and after the instruction, without ensuring their completion.
 887:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 888:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DMB(void)
 889:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 890:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dmb 0xF":::"memory");
 891:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 892:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 893:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 894:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 895:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (32 bit)
 896:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x785
 897:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 898:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 899:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 900:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV(uint32_t value)
 901:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 902:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
 903:Drivers/CMSIS/Include/cmsis_gcc.h ****   return __builtin_bswap32(value);
 904:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 905:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 906:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 907:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 908:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 909:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 910:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 911:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 912:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 913:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 914:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 915:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 
 916:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 917:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 918:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 919:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV16(uint32_t value)
 920:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 921:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 922:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 923:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 924:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 925:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 926:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 927:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 928:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 929:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 930:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For exam
 931:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 932:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 933:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 934:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE int16_t __REVSH(int16_t value)
 935:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 936:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 937:Drivers/CMSIS/Include/cmsis_gcc.h ****   return (int16_t)__builtin_bswap16(value);
 938:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 939:Drivers/CMSIS/Include/cmsis_gcc.h ****   int16_t result;
 940:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 941:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 32


 942:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 943:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 944:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 945:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 946:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 947:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 948:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Rotate Right in unsigned value (32 bit)
 949:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Rotate Right (immediate) provides the value of the contents of a register rotated by a v
 950:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    op1  Value to rotate
 951:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    op2  Number of Bits to rotate
 952:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Rotated value
 953:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 954:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
 955:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 956:Drivers/CMSIS/Include/cmsis_gcc.h ****   op2 %= 32U;
 957:Drivers/CMSIS/Include/cmsis_gcc.h ****   if (op2 == 0U)
 958:Drivers/CMSIS/Include/cmsis_gcc.h ****   {
 959:Drivers/CMSIS/Include/cmsis_gcc.h ****     return op1;
 960:Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 961:Drivers/CMSIS/Include/cmsis_gcc.h ****   return (op1 >> op2) | (op1 << (32U - op2));
 962:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 963:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 964:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 965:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 966:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Breakpoint
 967:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Causes the processor to enter Debug state.
 968:Drivers/CMSIS/Include/cmsis_gcc.h ****            Debug tools can use this to investigate system state when the instruction at a particula
 969:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  is ignored by the processor.
 970:Drivers/CMSIS/Include/cmsis_gcc.h ****                  If required, a debugger can use it to store additional information about the break
 971:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 972:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __BKPT(value)                       __ASM volatile ("bkpt "#value)
 973:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 974:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 975:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 976:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse bit order of value
 977:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the bit order of the given value.
 978:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 979:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 980:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 981:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __RBIT(uint32_t value)
 982:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 983:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 984:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 985:Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 986:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 987:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 988:Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 460              		.loc 2 988 4
 461 000c FB68     		ldr	r3, [r7, #12]
 462              		.syntax unified
 463              	@ 988 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 464 000e 93FAA3F3 		rbit r3, r3
 465              	@ 0 "" 2
 466              		.thumb
 467              		.syntax unified
 468 0012 BB60     		str	r3, [r7, #8]
 989:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 33


 990:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t s = (4U /*sizeof(v)*/ * 8U) - 1U; /* extra shift needed at end */
 991:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 992:Drivers/CMSIS/Include/cmsis_gcc.h ****   result = value;                      /* r will be reversed bits of v; first get LSB of v */
 993:Drivers/CMSIS/Include/cmsis_gcc.h ****   for (value >>= 1U; value != 0U; value >>= 1U)
 994:Drivers/CMSIS/Include/cmsis_gcc.h ****   {
 995:Drivers/CMSIS/Include/cmsis_gcc.h ****     result <<= 1U;
 996:Drivers/CMSIS/Include/cmsis_gcc.h ****     result |= value & 1U;
 997:Drivers/CMSIS/Include/cmsis_gcc.h ****     s--;
 998:Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 999:Drivers/CMSIS/Include/cmsis_gcc.h ****   result <<= s;                        /* shift when v's highest bits are zero */
1000:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
1001:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 469              		.loc 2 1001 10
 470 0014 BB68     		ldr	r3, [r7, #8]
 471              	.LBE7:
 472              	.LBE6:
 383:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Check the parameter */
 384:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));
 385:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Enable the EWUPx pin */
 386:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *(__IO uint32_t *) CSR_EWUP_BB(WakeUpPinx) = (uint32_t)ENABLE;
 473              		.loc 1 386 22
 474 0016 B3FA83F3 		clz	r3, r3
 475 001a DBB2     		uxtb	r3, r3
 476 001c 1A46     		mov	r2, r3
 477 001e 054B     		ldr	r3, .L27
 478 0020 1344     		add	r3, r3, r2
 479 0022 9B00     		lsls	r3, r3, #2
 480              		.loc 1 386 4
 481 0024 1A46     		mov	r2, r3
 482              		.loc 1 386 46
 483 0026 0123     		movs	r3, #1
 484 0028 1360     		str	r3, [r2]
 387:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 485              		.loc 1 387 1
 486 002a 00BF     		nop
 487 002c 1437     		adds	r7, r7, #20
 488              	.LCFI33:
 489              		.cfi_def_cfa_offset 4
 490 002e BD46     		mov	sp, r7
 491              	.LCFI34:
 492              		.cfi_def_cfa_register 13
 493              		@ sp needed
 494 0030 80BC     		pop	{r7}
 495              	.LCFI35:
 496              		.cfi_restore 7
 497              		.cfi_def_cfa_offset 0
 498 0032 7047     		bx	lr
 499              	.L28:
 500              		.align	2
 501              	.L27:
 502 0034 20808310 		.word	277053472
 503              		.cfi_endproc
 504              	.LFE72:
 506              		.section	.text.HAL_PWR_DisableWakeUpPin,"ax",%progbits
 507              		.align	1
 508              		.global	HAL_PWR_DisableWakeUpPin
 509              		.syntax unified
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 34


 510              		.thumb
 511              		.thumb_func
 513              	HAL_PWR_DisableWakeUpPin:
 514              	.LFB73:
 388:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 389:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 390:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Disables the WakeUp PINx functionality.
 391:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @param WakeUpPinx: Specifies the Power Wake-Up pin to disable.
 392:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *        This parameter can be one of the following values:
 393:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *           @arg PWR_WAKEUP_PIN1
 394:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 395:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 396:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx)
 397:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 515              		.loc 1 397 1
 516              		.cfi_startproc
 517              		@ args = 0, pretend = 0, frame = 16
 518              		@ frame_needed = 1, uses_anonymous_args = 0
 519              		@ link register save eliminated.
 520 0000 80B4     		push	{r7}
 521              	.LCFI36:
 522              		.cfi_def_cfa_offset 4
 523              		.cfi_offset 7, -4
 524 0002 85B0     		sub	sp, sp, #20
 525              	.LCFI37:
 526              		.cfi_def_cfa_offset 24
 527 0004 00AF     		add	r7, sp, #0
 528              	.LCFI38:
 529              		.cfi_def_cfa_register 7
 530 0006 7860     		str	r0, [r7, #4]
 531 0008 7B68     		ldr	r3, [r7, #4]
 532 000a FB60     		str	r3, [r7, #12]
 533              	.LBB8:
 534              	.LBB9:
 988:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 535              		.loc 2 988 4
 536 000c FB68     		ldr	r3, [r7, #12]
 537              		.syntax unified
 538              	@ 988 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 539 000e 93FAA3F3 		rbit r3, r3
 540              	@ 0 "" 2
 541              		.thumb
 542              		.syntax unified
 543 0012 BB60     		str	r3, [r7, #8]
 544              		.loc 2 1001 10
 545 0014 BB68     		ldr	r3, [r7, #8]
 546              	.LBE9:
 547              	.LBE8:
 398:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Check the parameter */
 399:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));
 400:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Disable the EWUPx pin */
 401:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *(__IO uint32_t *) CSR_EWUP_BB(WakeUpPinx) = (uint32_t)DISABLE;
 548              		.loc 1 401 22
 549 0016 B3FA83F3 		clz	r3, r3
 550 001a DBB2     		uxtb	r3, r3
 551 001c 1A46     		mov	r2, r3
 552 001e 054B     		ldr	r3, .L31
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 35


 553 0020 1344     		add	r3, r3, r2
 554 0022 9B00     		lsls	r3, r3, #2
 555              		.loc 1 401 4
 556 0024 1A46     		mov	r2, r3
 557              		.loc 1 401 46
 558 0026 0023     		movs	r3, #0
 559 0028 1360     		str	r3, [r2]
 402:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 560              		.loc 1 402 1
 561 002a 00BF     		nop
 562 002c 1437     		adds	r7, r7, #20
 563              	.LCFI39:
 564              		.cfi_def_cfa_offset 4
 565 002e BD46     		mov	sp, r7
 566              	.LCFI40:
 567              		.cfi_def_cfa_register 13
 568              		@ sp needed
 569 0030 80BC     		pop	{r7}
 570              	.LCFI41:
 571              		.cfi_restore 7
 572              		.cfi_def_cfa_offset 0
 573 0032 7047     		bx	lr
 574              	.L32:
 575              		.align	2
 576              	.L31:
 577 0034 20808310 		.word	277053472
 578              		.cfi_endproc
 579              	.LFE73:
 581              		.section	.text.HAL_PWR_EnterSLEEPMode,"ax",%progbits
 582              		.align	1
 583              		.global	HAL_PWR_EnterSLEEPMode
 584              		.syntax unified
 585              		.thumb
 586              		.thumb_func
 588              	HAL_PWR_EnterSLEEPMode:
 589              	.LFB74:
 403:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 404:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 405:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Enters Sleep mode.
 406:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note  In Sleep mode, all I/O pins keep the same state as in Run mode.
 407:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @param Regulator: Regulator state as no effect in SLEEP mode -  allows to support portability f
 408:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @param SLEEPEntry: Specifies if SLEEP mode is entered with WFI or WFE instruction.
 409:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *           When WFI entry is used, tick interrupt have to be disabled if not desired as 
 410:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *           the interrupt wake up source.
 411:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *           This parameter can be one of the following values:
 412:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *            @arg PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
 413:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *            @arg PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
 414:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 415:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 416:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
 417:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 590              		.loc 1 417 1
 591              		.cfi_startproc
 592              		@ args = 0, pretend = 0, frame = 8
 593              		@ frame_needed = 1, uses_anonymous_args = 0
 594              		@ link register save eliminated.
 595 0000 80B4     		push	{r7}
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 36


 596              	.LCFI42:
 597              		.cfi_def_cfa_offset 4
 598              		.cfi_offset 7, -4
 599 0002 83B0     		sub	sp, sp, #12
 600              	.LCFI43:
 601              		.cfi_def_cfa_offset 16
 602 0004 00AF     		add	r7, sp, #0
 603              	.LCFI44:
 604              		.cfi_def_cfa_register 7
 605 0006 7860     		str	r0, [r7, #4]
 606 0008 0B46     		mov	r3, r1
 607 000a FB70     		strb	r3, [r7, #3]
 418:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Check the parameters */
 419:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* No check on Regulator because parameter not used in SLEEP mode */
 420:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Prevent unused argument(s) compilation warning */
 421:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   UNUSED(Regulator);
 422:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 423:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));
 424:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 425:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Clear SLEEPDEEP bit of Cortex System Control Register */
 426:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 608              		.loc 1 426 3
 609 000c 094B     		ldr	r3, .L37
 610 000e 1B69     		ldr	r3, [r3, #16]
 611 0010 084A     		ldr	r2, .L37
 612 0012 23F00403 		bic	r3, r3, #4
 613 0016 1361     		str	r3, [r2, #16]
 427:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 428:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Select SLEEP mode entry -------------------------------------------------*/
 429:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   if(SLEEPEntry == PWR_SLEEPENTRY_WFI)
 614              		.loc 1 429 5
 615 0018 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 616 001a 012B     		cmp	r3, #1
 617 001c 01D1     		bne	.L34
 430:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
 431:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     /* Request Wait For Interrupt */
 432:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __WFI();
 618              		.loc 1 432 5
 619              		.syntax unified
 620              	@ 432 "Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
 621 001e 30BF     		wfi
 622              	@ 0 "" 2
 433:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 434:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   else
 435:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
 436:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     /* Request Wait For Event */
 437:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __SEV();
 438:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __WFE();
 439:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __WFE();
 440:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 441:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 623              		.loc 1 441 1
 624              		.thumb
 625              		.syntax unified
 626 0020 02E0     		b	.L36
 627              	.L34:
 437:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __WFE();
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 37


 628              		.loc 1 437 5
 629              		.syntax unified
 630              	@ 437 "Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
 631 0022 40BF     		sev
 632              	@ 0 "" 2
 438:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __WFE();
 633              		.loc 1 438 5
 634              	@ 438 "Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
 635 0024 20BF     		wfe
 636              	@ 0 "" 2
 439:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 637              		.loc 1 439 5
 638              	@ 439 "Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
 639 0026 20BF     		wfe
 640              	@ 0 "" 2
 641              		.thumb
 642              		.syntax unified
 643              	.L36:
 644              		.loc 1 441 1
 645 0028 00BF     		nop
 646 002a 0C37     		adds	r7, r7, #12
 647              	.LCFI45:
 648              		.cfi_def_cfa_offset 4
 649 002c BD46     		mov	sp, r7
 650              	.LCFI46:
 651              		.cfi_def_cfa_register 13
 652              		@ sp needed
 653 002e 80BC     		pop	{r7}
 654              	.LCFI47:
 655              		.cfi_restore 7
 656              		.cfi_def_cfa_offset 0
 657 0030 7047     		bx	lr
 658              	.L38:
 659 0032 00BF     		.align	2
 660              	.L37:
 661 0034 00ED00E0 		.word	-536810240
 662              		.cfi_endproc
 663              	.LFE74:
 665              		.section	.text.HAL_PWR_EnterSTOPMode,"ax",%progbits
 666              		.align	1
 667              		.global	HAL_PWR_EnterSTOPMode
 668              		.syntax unified
 669              		.thumb
 670              		.thumb_func
 672              	HAL_PWR_EnterSTOPMode:
 673              	.LFB75:
 442:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 443:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 444:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Enters Stop mode. 
 445:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note  In Stop mode, all I/O pins keep the same state as in Run mode.
 446:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note  When exiting Stop mode by using an interrupt or a wakeup event,
 447:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *        HSI RC oscillator is selected as system clock.
 448:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note  When the voltage regulator operates in low power mode, an additional
 449:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         startup delay is incurred when waking up from Stop mode. 
 450:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         By keeping the internal regulator ON during Stop mode, the consumption
 451:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         is higher although the startup time is reduced.    
 452:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @param Regulator: Specifies the regulator state in Stop mode.
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 38


 453:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *          This parameter can be one of the following values:
 454:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *            @arg PWR_MAINREGULATOR_ON: Stop mode with regulator ON
 455:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *            @arg PWR_LOWPOWERREGULATOR_ON: Stop mode with low power regulator ON
 456:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @param STOPEntry: Specifies if Stop mode in entered with WFI or WFE instruction.
 457:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *          This parameter can be one of the following values:
 458:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *            @arg PWR_STOPENTRY_WFI: Enter Stop mode with WFI instruction
 459:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *            @arg PWR_STOPENTRY_WFE: Enter Stop mode with WFE instruction   
 460:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 461:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 462:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
 463:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 674              		.loc 1 463 1
 675              		.cfi_startproc
 676              		@ args = 0, pretend = 0, frame = 8
 677              		@ frame_needed = 1, uses_anonymous_args = 0
 678 0000 80B5     		push	{r7, lr}
 679              	.LCFI48:
 680              		.cfi_def_cfa_offset 8
 681              		.cfi_offset 7, -8
 682              		.cfi_offset 14, -4
 683 0002 82B0     		sub	sp, sp, #8
 684              	.LCFI49:
 685              		.cfi_def_cfa_offset 16
 686 0004 00AF     		add	r7, sp, #0
 687              	.LCFI50:
 688              		.cfi_def_cfa_register 7
 689 0006 7860     		str	r0, [r7, #4]
 690 0008 0B46     		mov	r3, r1
 691 000a FB70     		strb	r3, [r7, #3]
 464:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Check the parameters */
 465:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_REGULATOR(Regulator));
 466:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
 467:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 468:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Clear PDDS bit in PWR register to specify entering in STOP mode when CPU enter in Deepsleep */
 469:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   CLEAR_BIT(PWR->CR,  PWR_CR_PDDS);
 692              		.loc 1 469 3
 693 000c 134B     		ldr	r3, .L42
 694 000e 1B68     		ldr	r3, [r3]
 695 0010 124A     		ldr	r2, .L42
 696 0012 23F00203 		bic	r3, r3, #2
 697 0016 1360     		str	r3, [r2]
 470:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 471:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Select the voltage regulator mode by setting LPDS bit in PWR register according to Regulator p
 472:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   MODIFY_REG(PWR->CR, PWR_CR_LPDS, Regulator);
 698              		.loc 1 472 3
 699 0018 104B     		ldr	r3, .L42
 700 001a 1B68     		ldr	r3, [r3]
 701 001c 23F00102 		bic	r2, r3, #1
 702 0020 0E49     		ldr	r1, .L42
 703 0022 7B68     		ldr	r3, [r7, #4]
 704 0024 1343     		orrs	r3, r3, r2
 705 0026 0B60     		str	r3, [r1]
 473:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 474:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 475:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 706              		.loc 1 475 3
 707 0028 0D4B     		ldr	r3, .L42+4
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 39


 708 002a 1B69     		ldr	r3, [r3, #16]
 709 002c 0C4A     		ldr	r2, .L42+4
 710 002e 43F00403 		orr	r3, r3, #4
 711 0032 1361     		str	r3, [r2, #16]
 476:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 477:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Select Stop mode entry --------------------------------------------------*/
 478:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   if(STOPEntry == PWR_STOPENTRY_WFI)
 712              		.loc 1 478 5
 713 0034 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 714 0036 012B     		cmp	r3, #1
 715 0038 01D1     		bne	.L40
 479:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
 480:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     /* Request Wait For Interrupt */
 481:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __WFI();
 716              		.loc 1 481 5
 717              		.syntax unified
 718              	@ 481 "Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
 719 003a 30BF     		wfi
 720              	@ 0 "" 2
 721              		.thumb
 722              		.syntax unified
 723 003c 04E0     		b	.L41
 724              	.L40:
 482:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 483:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   else
 484:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
 485:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     /* Request Wait For Event */
 486:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __SEV();
 725              		.loc 1 486 5
 726              		.syntax unified
 727              	@ 486 "Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
 728 003e 40BF     		sev
 729              	@ 0 "" 2
 487:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     PWR_OverloadWfe(); /* WFE redefine locally */
 730              		.loc 1 487 5
 731              		.thumb
 732              		.syntax unified
 733 0040 FFF7FEFF 		bl	PWR_OverloadWfe
 488:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     PWR_OverloadWfe(); /* WFE redefine locally */
 734              		.loc 1 488 5
 735 0044 FFF7FEFF 		bl	PWR_OverloadWfe
 736              	.L41:
 489:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 490:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Reset SLEEPDEEP bit of Cortex System Control Register */
 491:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 737              		.loc 1 491 3
 738 0048 054B     		ldr	r3, .L42+4
 739 004a 1B69     		ldr	r3, [r3, #16]
 740 004c 044A     		ldr	r2, .L42+4
 741 004e 23F00403 		bic	r3, r3, #4
 742 0052 1361     		str	r3, [r2, #16]
 492:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 743              		.loc 1 492 1
 744 0054 00BF     		nop
 745 0056 0837     		adds	r7, r7, #8
 746              	.LCFI51:
 747              		.cfi_def_cfa_offset 8
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 40


 748 0058 BD46     		mov	sp, r7
 749              	.LCFI52:
 750              		.cfi_def_cfa_register 13
 751              		@ sp needed
 752 005a 80BD     		pop	{r7, pc}
 753              	.L43:
 754              		.align	2
 755              	.L42:
 756 005c 00700040 		.word	1073770496
 757 0060 00ED00E0 		.word	-536810240
 758              		.cfi_endproc
 759              	.LFE75:
 761              		.section	.text.HAL_PWR_EnterSTANDBYMode,"ax",%progbits
 762              		.align	1
 763              		.global	HAL_PWR_EnterSTANDBYMode
 764              		.syntax unified
 765              		.thumb
 766              		.thumb_func
 768              	HAL_PWR_EnterSTANDBYMode:
 769              	.LFB76:
 493:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 494:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 495:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Enters Standby mode.
 496:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note  In Standby mode, all I/O pins are high impedance except for:
 497:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *          - Reset pad (still available) 
 498:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *          - TAMPER pin if configured for tamper or calibration out.
 499:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *          - WKUP pin (PA0) if enabled.
 500:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 501:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 502:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnterSTANDBYMode(void)
 503:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 770              		.loc 1 503 1
 771              		.cfi_startproc
 772              		@ args = 0, pretend = 0, frame = 0
 773              		@ frame_needed = 1, uses_anonymous_args = 0
 774              		@ link register save eliminated.
 775 0000 80B4     		push	{r7}
 776              	.LCFI53:
 777              		.cfi_def_cfa_offset 4
 778              		.cfi_offset 7, -4
 779 0002 00AF     		add	r7, sp, #0
 780              	.LCFI54:
 781              		.cfi_def_cfa_register 7
 504:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Select Standby mode */
 505:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   SET_BIT(PWR->CR, PWR_CR_PDDS);
 782              		.loc 1 505 3
 783 0004 084B     		ldr	r3, .L45
 784 0006 1B68     		ldr	r3, [r3]
 785 0008 074A     		ldr	r2, .L45
 786 000a 43F00203 		orr	r3, r3, #2
 787 000e 1360     		str	r3, [r2]
 506:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 507:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 508:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 788              		.loc 1 508 3
 789 0010 064B     		ldr	r3, .L45+4
 790 0012 1B69     		ldr	r3, [r3, #16]
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 41


 791 0014 054A     		ldr	r2, .L45+4
 792 0016 43F00403 		orr	r3, r3, #4
 793 001a 1361     		str	r3, [r2, #16]
 509:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 510:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* This option is used to ensure that store operations are completed */
 511:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #if defined ( __CC_ARM)
 512:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __force_stores();
 513:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #endif
 514:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Request Wait For Interrupt */
 515:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __WFI();
 794              		.loc 1 515 3
 795              		.syntax unified
 796              	@ 515 "Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
 797 001c 30BF     		wfi
 798              	@ 0 "" 2
 516:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 799              		.loc 1 516 1
 800              		.thumb
 801              		.syntax unified
 802 001e 00BF     		nop
 803 0020 BD46     		mov	sp, r7
 804              	.LCFI55:
 805              		.cfi_def_cfa_register 13
 806              		@ sp needed
 807 0022 80BC     		pop	{r7}
 808              	.LCFI56:
 809              		.cfi_restore 7
 810              		.cfi_def_cfa_offset 0
 811 0024 7047     		bx	lr
 812              	.L46:
 813 0026 00BF     		.align	2
 814              	.L45:
 815 0028 00700040 		.word	1073770496
 816 002c 00ED00E0 		.word	-536810240
 817              		.cfi_endproc
 818              	.LFE76:
 820              		.section	.text.HAL_PWR_EnableSleepOnExit,"ax",%progbits
 821              		.align	1
 822              		.global	HAL_PWR_EnableSleepOnExit
 823              		.syntax unified
 824              		.thumb
 825              		.thumb_func
 827              	HAL_PWR_EnableSleepOnExit:
 828              	.LFB77:
 517:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 518:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 519:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 520:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Indicates Sleep-On-Exit when returning from Handler mode to Thread mode. 
 521:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note Set SLEEPONEXIT bit of SCR register. When this bit is set, the processor 
 522:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *       re-enters SLEEP mode when an interruption handling is over.
 523:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *       Setting this bit is useful when the processor is expected to run only on
 524:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *       interruptions handling.         
 525:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 526:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 527:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnableSleepOnExit(void)
 528:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 829              		.loc 1 528 1
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 42


 830              		.cfi_startproc
 831              		@ args = 0, pretend = 0, frame = 0
 832              		@ frame_needed = 1, uses_anonymous_args = 0
 833              		@ link register save eliminated.
 834 0000 80B4     		push	{r7}
 835              	.LCFI57:
 836              		.cfi_def_cfa_offset 4
 837              		.cfi_offset 7, -4
 838 0002 00AF     		add	r7, sp, #0
 839              	.LCFI58:
 840              		.cfi_def_cfa_register 7
 529:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Set SLEEPONEXIT bit of Cortex System Control Register */
 530:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
 841              		.loc 1 530 3
 842 0004 044B     		ldr	r3, .L48
 843 0006 1B69     		ldr	r3, [r3, #16]
 844 0008 034A     		ldr	r2, .L48
 845 000a 43F00203 		orr	r3, r3, #2
 846 000e 1361     		str	r3, [r2, #16]
 531:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 847              		.loc 1 531 1
 848 0010 00BF     		nop
 849 0012 BD46     		mov	sp, r7
 850              	.LCFI59:
 851              		.cfi_def_cfa_register 13
 852              		@ sp needed
 853 0014 80BC     		pop	{r7}
 854              	.LCFI60:
 855              		.cfi_restore 7
 856              		.cfi_def_cfa_offset 0
 857 0016 7047     		bx	lr
 858              	.L49:
 859              		.align	2
 860              	.L48:
 861 0018 00ED00E0 		.word	-536810240
 862              		.cfi_endproc
 863              	.LFE77:
 865              		.section	.text.HAL_PWR_DisableSleepOnExit,"ax",%progbits
 866              		.align	1
 867              		.global	HAL_PWR_DisableSleepOnExit
 868              		.syntax unified
 869              		.thumb
 870              		.thumb_func
 872              	HAL_PWR_DisableSleepOnExit:
 873              	.LFB78:
 532:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 533:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 534:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 535:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Disables Sleep-On-Exit feature when returning from Handler mode to Thread mode. 
 536:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note Clears SLEEPONEXIT bit of SCR register. When this bit is set, the processor 
 537:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *       re-enters SLEEP mode when an interruption handling is over.          
 538:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 539:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 540:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_DisableSleepOnExit(void)
 541:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 874              		.loc 1 541 1
 875              		.cfi_startproc
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 43


 876              		@ args = 0, pretend = 0, frame = 0
 877              		@ frame_needed = 1, uses_anonymous_args = 0
 878              		@ link register save eliminated.
 879 0000 80B4     		push	{r7}
 880              	.LCFI61:
 881              		.cfi_def_cfa_offset 4
 882              		.cfi_offset 7, -4
 883 0002 00AF     		add	r7, sp, #0
 884              	.LCFI62:
 885              		.cfi_def_cfa_register 7
 542:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Clear SLEEPONEXIT bit of Cortex System Control Register */
 543:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
 886              		.loc 1 543 3
 887 0004 044B     		ldr	r3, .L51
 888 0006 1B69     		ldr	r3, [r3, #16]
 889 0008 034A     		ldr	r2, .L51
 890 000a 23F00203 		bic	r3, r3, #2
 891 000e 1361     		str	r3, [r2, #16]
 544:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 892              		.loc 1 544 1
 893 0010 00BF     		nop
 894 0012 BD46     		mov	sp, r7
 895              	.LCFI63:
 896              		.cfi_def_cfa_register 13
 897              		@ sp needed
 898 0014 80BC     		pop	{r7}
 899              	.LCFI64:
 900              		.cfi_restore 7
 901              		.cfi_def_cfa_offset 0
 902 0016 7047     		bx	lr
 903              	.L52:
 904              		.align	2
 905              	.L51:
 906 0018 00ED00E0 		.word	-536810240
 907              		.cfi_endproc
 908              	.LFE78:
 910              		.section	.text.HAL_PWR_EnableSEVOnPend,"ax",%progbits
 911              		.align	1
 912              		.global	HAL_PWR_EnableSEVOnPend
 913              		.syntax unified
 914              		.thumb
 915              		.thumb_func
 917              	HAL_PWR_EnableSEVOnPend:
 918              	.LFB79:
 545:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 546:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 547:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 548:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Enables CORTEX M3 SEVONPEND bit. 
 549:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note Sets SEVONPEND bit of SCR register. When this bit is set, this causes 
 550:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *       WFE to wake up when an interrupt moves from inactive to pended.
 551:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 552:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 553:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnableSEVOnPend(void)
 554:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 919              		.loc 1 554 1
 920              		.cfi_startproc
 921              		@ args = 0, pretend = 0, frame = 0
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 44


 922              		@ frame_needed = 1, uses_anonymous_args = 0
 923              		@ link register save eliminated.
 924 0000 80B4     		push	{r7}
 925              	.LCFI65:
 926              		.cfi_def_cfa_offset 4
 927              		.cfi_offset 7, -4
 928 0002 00AF     		add	r7, sp, #0
 929              	.LCFI66:
 930              		.cfi_def_cfa_register 7
 555:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Set SEVONPEND bit of Cortex System Control Register */
 556:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
 931              		.loc 1 556 3
 932 0004 044B     		ldr	r3, .L54
 933 0006 1B69     		ldr	r3, [r3, #16]
 934 0008 034A     		ldr	r2, .L54
 935 000a 43F01003 		orr	r3, r3, #16
 936 000e 1361     		str	r3, [r2, #16]
 557:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 937              		.loc 1 557 1
 938 0010 00BF     		nop
 939 0012 BD46     		mov	sp, r7
 940              	.LCFI67:
 941              		.cfi_def_cfa_register 13
 942              		@ sp needed
 943 0014 80BC     		pop	{r7}
 944              	.LCFI68:
 945              		.cfi_restore 7
 946              		.cfi_def_cfa_offset 0
 947 0016 7047     		bx	lr
 948              	.L55:
 949              		.align	2
 950              	.L54:
 951 0018 00ED00E0 		.word	-536810240
 952              		.cfi_endproc
 953              	.LFE79:
 955              		.section	.text.HAL_PWR_DisableSEVOnPend,"ax",%progbits
 956              		.align	1
 957              		.global	HAL_PWR_DisableSEVOnPend
 958              		.syntax unified
 959              		.thumb
 960              		.thumb_func
 962              	HAL_PWR_DisableSEVOnPend:
 963              	.LFB80:
 558:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 559:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 560:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 561:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Disables CORTEX M3 SEVONPEND bit. 
 562:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note Clears SEVONPEND bit of SCR register. When this bit is set, this causes 
 563:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *       WFE to wake up when an interrupt moves from inactive to pended.         
 564:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 565:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 566:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_DisableSEVOnPend(void)
 567:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 964              		.loc 1 567 1
 965              		.cfi_startproc
 966              		@ args = 0, pretend = 0, frame = 0
 967              		@ frame_needed = 1, uses_anonymous_args = 0
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 45


 968              		@ link register save eliminated.
 969 0000 80B4     		push	{r7}
 970              	.LCFI69:
 971              		.cfi_def_cfa_offset 4
 972              		.cfi_offset 7, -4
 973 0002 00AF     		add	r7, sp, #0
 974              	.LCFI70:
 975              		.cfi_def_cfa_register 7
 568:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Clear SEVONPEND bit of Cortex System Control Register */
 569:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
 976              		.loc 1 569 3
 977 0004 044B     		ldr	r3, .L57
 978 0006 1B69     		ldr	r3, [r3, #16]
 979 0008 034A     		ldr	r2, .L57
 980 000a 23F01003 		bic	r3, r3, #16
 981 000e 1361     		str	r3, [r2, #16]
 570:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 982              		.loc 1 570 1
 983 0010 00BF     		nop
 984 0012 BD46     		mov	sp, r7
 985              	.LCFI71:
 986              		.cfi_def_cfa_register 13
 987              		@ sp needed
 988 0014 80BC     		pop	{r7}
 989              	.LCFI72:
 990              		.cfi_restore 7
 991              		.cfi_def_cfa_offset 0
 992 0016 7047     		bx	lr
 993              	.L58:
 994              		.align	2
 995              	.L57:
 996 0018 00ED00E0 		.word	-536810240
 997              		.cfi_endproc
 998              	.LFE80:
 1000              		.section	.text.HAL_PWR_PVD_IRQHandler,"ax",%progbits
 1001              		.align	1
 1002              		.global	HAL_PWR_PVD_IRQHandler
 1003              		.syntax unified
 1004              		.thumb
 1005              		.thumb_func
 1007              	HAL_PWR_PVD_IRQHandler:
 1008              	.LFB81:
 571:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 572:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 573:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 574:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 575:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief  This function handles the PWR PVD interrupt request.
 576:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note   This API should be called under the PVD_IRQHandler().
 577:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 578:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 579:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_PVD_IRQHandler(void)
 580:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 1009              		.loc 1 580 1
 1010              		.cfi_startproc
 1011              		@ args = 0, pretend = 0, frame = 0
 1012              		@ frame_needed = 1, uses_anonymous_args = 0
 1013 0000 80B5     		push	{r7, lr}
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 46


 1014              	.LCFI73:
 1015              		.cfi_def_cfa_offset 8
 1016              		.cfi_offset 7, -8
 1017              		.cfi_offset 14, -4
 1018 0002 00AF     		add	r7, sp, #0
 1019              	.LCFI74:
 1020              		.cfi_def_cfa_register 7
 581:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Check PWR exti flag */
 582:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)
 1021              		.loc 1 582 6
 1022 0004 064B     		ldr	r3, .L62
 1023 0006 5B69     		ldr	r3, [r3, #20]
 1024 0008 03F48033 		and	r3, r3, #65536
 1025              		.loc 1 582 5
 1026 000c 002B     		cmp	r3, #0
 1027 000e 05D0     		beq	.L61
 583:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
 584:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     /* PWR PVD interrupt user callback */
 585:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     HAL_PWR_PVDCallback();
 1028              		.loc 1 585 5
 1029 0010 FFF7FEFF 		bl	HAL_PWR_PVDCallback
 586:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 587:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     /* Clear PWR Exti pending bit */
 588:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
 1030              		.loc 1 588 5
 1031 0014 024B     		ldr	r3, .L62
 1032 0016 4FF48032 		mov	r2, #65536
 1033 001a 5A61     		str	r2, [r3, #20]
 1034              	.L61:
 589:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 590:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 1035              		.loc 1 590 1
 1036 001c 00BF     		nop
 1037 001e 80BD     		pop	{r7, pc}
 1038              	.L63:
 1039              		.align	2
 1040              	.L62:
 1041 0020 00040140 		.word	1073808384
 1042              		.cfi_endproc
 1043              	.LFE81:
 1045              		.section	.text.HAL_PWR_PVDCallback,"ax",%progbits
 1046              		.align	1
 1047              		.weak	HAL_PWR_PVDCallback
 1048              		.syntax unified
 1049              		.thumb
 1050              		.thumb_func
 1052              	HAL_PWR_PVDCallback:
 1053              	.LFB82:
 591:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 592:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 593:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief  PWR PVD interrupt callback
 594:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 595:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 596:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** __weak void HAL_PWR_PVDCallback(void)
 597:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 1054              		.loc 1 597 1
 1055              		.cfi_startproc
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 47


 1056              		@ args = 0, pretend = 0, frame = 0
 1057              		@ frame_needed = 1, uses_anonymous_args = 0
 1058              		@ link register save eliminated.
 1059 0000 80B4     		push	{r7}
 1060              	.LCFI75:
 1061              		.cfi_def_cfa_offset 4
 1062              		.cfi_offset 7, -4
 1063 0002 00AF     		add	r7, sp, #0
 1064              	.LCFI76:
 1065              		.cfi_def_cfa_register 7
 598:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* NOTE : This function Should not be modified, when the callback is needed,
 599:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****             the HAL_PWR_PVDCallback could be implemented in the user file
 600:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    */ 
 601:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 1066              		.loc 1 601 1
 1067 0004 00BF     		nop
 1068 0006 BD46     		mov	sp, r7
 1069              	.LCFI77:
 1070              		.cfi_def_cfa_register 13
 1071              		@ sp needed
 1072 0008 80BC     		pop	{r7}
 1073              	.LCFI78:
 1074              		.cfi_restore 7
 1075              		.cfi_def_cfa_offset 0
 1076 000a 7047     		bx	lr
 1077              		.cfi_endproc
 1078              	.LFE82:
 1080              		.text
 1081              	.Letext0:
 1082              		.file 3 "d:\\portable programs\\stm32-my-toolchain\\gcc-arm-none-eabi-10.3-2021.10\\arm-none-eabi\
 1083              		.file 4 "d:\\portable programs\\stm32-my-toolchain\\gcc-arm-none-eabi-10.3-2021.10\\arm-none-eabi\
 1084              		.file 5 "Drivers/CMSIS/Include/core_cm3.h"
 1085              		.file 6 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
 1086              		.file 7 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h"
 1087              		.file 8 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_pwr.h"
ARM GAS  C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s 			page 48


DEFINED SYMBOLS
                            *ABS*:00000000 stm32f1xx_hal_pwr.c
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:18     .text.PWR_OverloadWfe:00000000 $t
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:23     .text.PWR_OverloadWfe:00000000 PWR_OverloadWfe
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:64     .text.HAL_PWR_DeInit:00000000 $t
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:70     .text.HAL_PWR_DeInit:00000000 HAL_PWR_DeInit
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:110    .text.HAL_PWR_DeInit:00000024 $d
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:115    .text.HAL_PWR_EnableBkUpAccess:00000000 $t
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:121    .text.HAL_PWR_EnableBkUpAccess:00000000 HAL_PWR_EnableBkUpAccess
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:154    .text.HAL_PWR_EnableBkUpAccess:00000014 $d
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:159    .text.HAL_PWR_DisableBkUpAccess:00000000 $t
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:165    .text.HAL_PWR_DisableBkUpAccess:00000000 HAL_PWR_DisableBkUpAccess
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:198    .text.HAL_PWR_DisableBkUpAccess:00000014 $d
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:203    .text.HAL_PWR_ConfigPVD:00000000 $t
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:209    .text.HAL_PWR_ConfigPVD:00000000 HAL_PWR_ConfigPVD
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:337    .text.HAL_PWR_ConfigPVD:000000b4 $d
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:343    .text.HAL_PWR_EnablePVD:00000000 $t
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:349    .text.HAL_PWR_EnablePVD:00000000 HAL_PWR_EnablePVD
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:382    .text.HAL_PWR_EnablePVD:00000014 $d
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:387    .text.HAL_PWR_DisablePVD:00000000 $t
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:393    .text.HAL_PWR_DisablePVD:00000000 HAL_PWR_DisablePVD
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:426    .text.HAL_PWR_DisablePVD:00000014 $d
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:431    .text.HAL_PWR_EnableWakeUpPin:00000000 $t
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:437    .text.HAL_PWR_EnableWakeUpPin:00000000 HAL_PWR_EnableWakeUpPin
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:502    .text.HAL_PWR_EnableWakeUpPin:00000034 $d
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:507    .text.HAL_PWR_DisableWakeUpPin:00000000 $t
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:513    .text.HAL_PWR_DisableWakeUpPin:00000000 HAL_PWR_DisableWakeUpPin
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:577    .text.HAL_PWR_DisableWakeUpPin:00000034 $d
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:582    .text.HAL_PWR_EnterSLEEPMode:00000000 $t
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:588    .text.HAL_PWR_EnterSLEEPMode:00000000 HAL_PWR_EnterSLEEPMode
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:661    .text.HAL_PWR_EnterSLEEPMode:00000034 $d
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:666    .text.HAL_PWR_EnterSTOPMode:00000000 $t
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:672    .text.HAL_PWR_EnterSTOPMode:00000000 HAL_PWR_EnterSTOPMode
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:756    .text.HAL_PWR_EnterSTOPMode:0000005c $d
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:762    .text.HAL_PWR_EnterSTANDBYMode:00000000 $t
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:768    .text.HAL_PWR_EnterSTANDBYMode:00000000 HAL_PWR_EnterSTANDBYMode
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:815    .text.HAL_PWR_EnterSTANDBYMode:00000028 $d
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:821    .text.HAL_PWR_EnableSleepOnExit:00000000 $t
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:827    .text.HAL_PWR_EnableSleepOnExit:00000000 HAL_PWR_EnableSleepOnExit
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:861    .text.HAL_PWR_EnableSleepOnExit:00000018 $d
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:866    .text.HAL_PWR_DisableSleepOnExit:00000000 $t
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:872    .text.HAL_PWR_DisableSleepOnExit:00000000 HAL_PWR_DisableSleepOnExit
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:906    .text.HAL_PWR_DisableSleepOnExit:00000018 $d
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:911    .text.HAL_PWR_EnableSEVOnPend:00000000 $t
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:917    .text.HAL_PWR_EnableSEVOnPend:00000000 HAL_PWR_EnableSEVOnPend
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:951    .text.HAL_PWR_EnableSEVOnPend:00000018 $d
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:956    .text.HAL_PWR_DisableSEVOnPend:00000000 $t
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:962    .text.HAL_PWR_DisableSEVOnPend:00000000 HAL_PWR_DisableSEVOnPend
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:996    .text.HAL_PWR_DisableSEVOnPend:00000018 $d
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:1001   .text.HAL_PWR_PVD_IRQHandler:00000000 $t
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:1007   .text.HAL_PWR_PVD_IRQHandler:00000000 HAL_PWR_PVD_IRQHandler
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:1052   .text.HAL_PWR_PVDCallback:00000000 HAL_PWR_PVDCallback
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:1041   .text.HAL_PWR_PVD_IRQHandler:00000020 $d
C:\Users\Matvey\AppData\Local\Temp\ccCJRhQ4.s:1046   .text.HAL_PWR_PVDCallback:00000000 $t

NO UNDEFINED SYMBOLS
